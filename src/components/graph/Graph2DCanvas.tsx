import { useRef, useEffect, useCallback, useMemo, useState } from 'react'
import { useGraphStore } from '@/stores/graphStore'
import { useUIStore } from '@/stores/uiStore'
import { useSettingsStore } from '@/stores/settingsStore'
import { useGraphSimulation, type SimNode, type SimLink } from '@/hooks/useGraphSimulation'
import { buildNodeColorMap, getNodeColor, lightenColor } from '@/lib/nodeColors'
import type { GraphNode } from '@/types'
import NodeTooltip from './NodeTooltip'

interface Props {
  width: number
  height: number
}

function getCSSVar(name: string, fallback: string): string {
  return getComputedStyle(document.documentElement).getPropertyValue(name).trim() || fallback
}

/**
 * Canvas-based 2D graph renderer for fast mode.
 * Single DOM element regardless of node count — no per-node React reconciliation.
 * Renders once after simulation completes; redraws only on view/selection changes.
 */
export default function Graph2DCanvas({ width, height }: Props) {
  const { nodes, links, selectedNodeId, physics, setSelectedNode, setGraphLayoutReady } = useGraphStore()
  const { nodeColorMode, setSelectedDoc, openInEditor } = useUIStore()
  const showNodeLabels = useSettingsStore(s => s.showNodeLabels)
  const tagColors = useSettingsStore(s => s.tagColors)
  const folderColors = useSettingsStore(s => s.folderColors)

  const nodeColorMap = useMemo(
    () => buildNodeColorMap(nodes, nodeColorMode, tagColors, folderColors),
    [nodes, nodeColorMode, tagColors, folderColors]
  )

  const canvasRef = useRef<HTMLCanvasElement>(null)
  const viewRef = useRef({ x: 0, y: 0, scale: 1 })
  const cachedSimNodesRef = useRef<SimNode[]>([])
  const cachedSimLinksRef = useRef<SimLink[]>([])
  const isPanningRef = useRef(false)
  const panStartRef = useRef({ mx: 0, my: 0, tx: 0, ty: 0 })
  const [tooltip, setTooltip] = useState<{ nodeId: string; x: number; y: number } | null>(null)

  // Stable refs for reactive values (keeps drawCanvas stable across re-renders)
  const selectedNodeIdRef = useRef(selectedNodeId)
  selectedNodeIdRef.current = selectedNodeId
  const showNodeLabelsRef = useRef(showNodeLabels)
  showNodeLabelsRef.current = showNodeLabels
  const nodeColorModeRef = useRef(nodeColorMode)
  nodeColorModeRef.current = nodeColorMode
  const nodeColorMapRef = useRef(nodeColorMap)
  nodeColorMapRef.current = nodeColorMap
  const physicsRef = useRef(physics)
  physicsRef.current = physics

  // O(1) node lookup — rebuilt when nodes change
  const nodeMapRef = useRef<Map<string, GraphNode>>(new Map())
  useEffect(() => {
    nodeMapRef.current = new Map(nodes.map(n => [n.id, n]))
  }, [nodes])

  // Degree map — rebuilt when links change (for Obsidian-style sizing)
  const degreeMapRef = useRef<Map<string, number>>(new Map())
  const maxDegreeRef = useRef(1)
  useEffect(() => {
    const map = new Map<string, number>()
    for (const l of links) {
      const s = typeof l.source === 'string' ? l.source : (l.source as { id: string }).id
      const t = typeof l.target === 'string' ? l.target : (l.target as { id: string }).id
      map.set(s, (map.get(s) ?? 0) + 1)
      map.set(t, (map.get(t) ?? 0) + 1)
    }
    degreeMapRef.current = map
    maxDegreeRef.current = Math.max(1, ...map.values())
  }, [links])

  // ── Draw everything to canvas ───────────────────────────────────────────────
  const drawCanvas = useCallback(() => {
    const canvas = canvasRef.current
    if (!canvas) return
    const ctx = canvas.getContext('2d')
    if (!ctx) return

    const simNodes = cachedSimNodesRef.current
    const simLinks = cachedSimLinksRef.current
    if (simNodes.length === 0) return

    const { x: tx, y: ty, scale } = viewRef.current
    const nodeMap = nodeMapRef.current
    const selId = selectedNodeIdRef.current
    const colorMode = nodeColorModeRef.current
    const colorMap = nodeColorMapRef.current

    ctx.clearRect(0, 0, width, height)
    ctx.save()
    ctx.translate(tx, ty)
    ctx.scale(scale, scale)

    // ── Links (single batched path — all same style) ────────────────────────
    ctx.strokeStyle = getCSSVar('--color-border', '#333')
    ctx.lineWidth = 1 / scale
    ctx.globalAlpha = physicsRef.current.linkOpacity
    ctx.beginPath()
    for (const link of simLinks) {
      const src = link.source as SimNode
      const tgt = link.target as SimNode
      if (src?.x == null || tgt?.x == null) continue
      ctx.moveTo(src.x, src.y)
      ctx.lineTo(tgt.x, tgt.y)
    }
    ctx.stroke()

    // ── Nodes ───────────────────────────────────────────────────────────────
    const degreeMap = degreeMapRef.current
    const maxDeg = maxDegreeRef.current
    for (const simNode of simNodes) {
      const nodeData = nodeMap.get(simNode.id)
      if (!nodeData) continue
      const color = getNodeColor(nodeData, colorMode, colorMap)
      const isSelected = simNode.id === selId

      // Obsidian-style: radius scales with sqrt(degree+1)
      const deg = degreeMap.get(simNode.id) ?? 0
      const baseNr = physicsRef.current.nodeRadius
      const scaleFactor = Math.sqrt((deg + 1) / (maxDeg + 1))
      // clamp: min 55% ~ max 100% of baseNr
      const sizeScale = 0.55 + scaleFactor * 0.45
      const nr = baseNr * sizeScale

      // Brightness: low-degree nodes get white mixed in (max 55% white → 0% white)
      // Selected node always shows original color
      const lightFactor = isSelected ? 0 : (1 - scaleFactor) * 0.55
      ctx.globalAlpha = isSelected ? 1 : 0.9
      ctx.fillStyle = lightFactor > 0 ? lightenColor(color, lightFactor) : color

      if (nodeData.isImage) {
        // 이미지 노드: 다이아몬드(마름모) 형태
        const r = isSelected ? nr + 2 : Math.max(nr - 1, 2)
        ctx.save()
        ctx.translate(simNode.x, simNode.y)
        ctx.rotate(Math.PI / 4)
        ctx.beginPath()
        ctx.rect(-r / 1.41, -r / 1.41, r * 1.41, r * 1.41)
        ctx.fill()
        ctx.restore()
      } else {
        ctx.beginPath()
        ctx.arc(simNode.x, simNode.y, isSelected ? nr + 3 : nr, 0, Math.PI * 2)
        ctx.fill()
      }
    }

    // ── Selection ring (on top of nodes) ────────────────────────────────────
    if (selId) {
      const selNode = simNodes.find(n => n.id === selId)
      if (selNode) {
        const nodeData = nodeMap.get(selId)
        const color = nodeData ? getNodeColor(nodeData, colorMode, colorMap) : '#60a5fa'
        ctx.globalAlpha = 0.8
        ctx.strokeStyle = color
        ctx.lineWidth = 1.5 / scale
        ctx.setLineDash([4 / scale, 3 / scale])
        ctx.beginPath()
        const selDeg = degreeMapRef.current.get(selId) ?? 0
        const selMaxDeg = maxDegreeRef.current
        const selSizeFactor = 0.55 + Math.sqrt((selDeg + 1) / (selMaxDeg + 1)) * 0.45
        const selNr = physicsRef.current.nodeRadius * selSizeFactor
        ctx.arc(selNode.x, selNode.y, (selNr + 8) / scale, 0, Math.PI * 2)
        ctx.stroke()
        ctx.setLineDash([])
      }
    }

    // ── Labels ──────────────────────────────────────────────────────────────
    if (showNodeLabelsRef.current) {
      const textColor = getCSSVar('--color-text-secondary', '#888')
      ctx.fillStyle = textColor
      ctx.textAlign = 'center'
      // Font size in graph-space so screen size stays ~11px regardless of zoom
      ctx.font = `${11 / scale}px ui-monospace, monospace`
      for (const simNode of simNodes) {
        const nodeData = nodeMap.get(simNode.id)
        if (!nodeData) continue
        const label = nodeData.label.length > 16 ? nodeData.label.slice(0, 15) + '…' : nodeData.label
        ctx.globalAlpha = simNode.id === selId ? 0.95 : 0.7
        ctx.fillText(label, simNode.x, simNode.y + 16 / scale)
      }
    }

    ctx.restore()
  }, [width, height])

  // ── Fit bounding box into viewport ──────────────────────────────────────────
  const fitView = useCallback((simNodes: SimNode[]) => {
    if (simNodes.length === 0) return
    let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity
    for (const n of simNodes) {
      if (n.x < minX) minX = n.x; if (n.x > maxX) maxX = n.x
      if (n.y < minY) minY = n.y; if (n.y > maxY) maxY = n.y
    }
    const graphW = Math.max(maxX - minX, 100)
    const graphH = Math.max(maxY - minY, 100)
    const padding = 48
    const scale = Math.min((width - padding * 2) / graphW, (height - padding * 2) / graphH, 2)
    const cx = (minX + maxX) / 2
    const cy = (minY + maxY) / 2
    viewRef.current = { x: width / 2 - cx * scale, y: height / 2 - cy * scale, scale }
  }, [width, height])

  // ── Simulation ──────────────────────────────────────────────────────────────
  const handleTick = useCallback((sn: SimNode[], sl: SimLink[]) => {
    cachedSimNodesRef.current = sn
    cachedSimLinksRef.current = sl
  }, [])

  const handleComplete = useCallback((simNodes: SimNode[]) => {
    fitView(simNodes)
    drawCanvas()
    setGraphLayoutReady(true)
  }, [fitView, drawCanvas, setGraphLayoutReady])

  useGraphSimulation({ width, height, onTick: handleTick, onComplete: handleComplete })

  // ── Redraw when selection or color settings change ───────────────────────────
  useEffect(() => {
    if (cachedSimNodesRef.current.length > 0) drawCanvas()
    // drawCanvas is stable (only changes with width/height), listed deps are the triggers
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [selectedNodeId, showNodeLabels, nodeColorMode, nodeColorMap, physics.nodeRadius, links])

  // ── Wheel zoom ───────────────────────────────────────────────────────────────
  const handleWheel = useCallback((e: WheelEvent) => {
    e.preventDefault()
    const canvas = canvasRef.current
    if (!canvas) return
    const rect = canvas.getBoundingClientRect()
    const view = viewRef.current
    const mouseX = e.clientX - rect.left
    const mouseY = e.clientY - rect.top
    const zoomFactor = e.deltaY < 0 ? 1.12 : 1 / 1.12
    const newScale = Math.min(6, Math.max(0.15, view.scale * zoomFactor))
    const ratio = newScale / view.scale
    viewRef.current = {
      x: mouseX - ratio * (mouseX - view.x),
      y: mouseY - ratio * (mouseY - view.y),
      scale: newScale,
    }
    drawCanvas()
  }, [drawCanvas])

  useEffect(() => {
    const canvas = canvasRef.current
    if (!canvas) return
    canvas.addEventListener('wheel', handleWheel, { passive: false })
    return () => canvas.removeEventListener('wheel', handleWheel)
  }, [handleWheel])

  // ── Hit test: find node at screen coords ────────────────────────────────────
  const hitTest = useCallback((clientX: number, clientY: number): SimNode | null => {
    const canvas = canvasRef.current
    if (!canvas) return null
    const rect = canvas.getBoundingClientRect()
    const { x, y, scale } = viewRef.current
    const gx = (clientX - rect.left - x) / scale
    const gy = (clientY - rect.top - y) / scale
    const hitRadius = 12 / scale  // 12 screen-px in graph space
    let closest: SimNode | null = null
    let closestDist = hitRadius
    for (const node of cachedSimNodesRef.current) {
      const d = Math.sqrt((node.x - gx) ** 2 + (node.y - gy) ** 2)
      if (d < closestDist) { closestDist = d; closest = node }
    }
    return closest
  }, [])

  // ── Mouse / pan interactions ─────────────────────────────────────────────────
  const handleMouseDown = useCallback((e: React.MouseEvent<HTMLCanvasElement>) => {
    isPanningRef.current = true
    panStartRef.current = { mx: e.clientX, my: e.clientY, tx: viewRef.current.x, ty: viewRef.current.y }
  }, [])

  const handleMouseMove = useCallback((e: React.MouseEvent<HTMLCanvasElement>) => {
    if (!isPanningRef.current) return
    const dx = e.clientX - panStartRef.current.mx
    const dy = e.clientY - panStartRef.current.my
    viewRef.current = { ...viewRef.current, x: panStartRef.current.tx + dx, y: panStartRef.current.ty + dy }
    drawCanvas()
  }, [drawCanvas])

  const handleMouseUp = useCallback(() => { isPanningRef.current = false }, [])

  const handleClick = useCallback((e: React.MouseEvent<HTMLCanvasElement>) => {
    // Ignore if this was a drag (not a true click)
    if (Math.abs(e.clientX - panStartRef.current.mx) > 3 ||
        Math.abs(e.clientY - panStartRef.current.my) > 3) return
    const node = hitTest(e.clientX, e.clientY)
    if (node) {
      setSelectedNode(node.id)
      setTooltip({ nodeId: node.id, x: e.clientX, y: e.clientY })
    } else {
      setTooltip(null)
    }
  }, [hitTest, setSelectedNode])

  const handleDoubleClick = useCallback((e: React.MouseEvent<HTMLCanvasElement>) => {
    const node = hitTest(e.clientX, e.clientY)
    if (!node) return
    const nodeData = nodeMapRef.current.get(node.id)
    if (!nodeData) return
    setSelectedNode(node.id)
    setSelectedDoc(nodeData.docId)
    if (!nodeData.docId.startsWith('_phantom_')) openInEditor(nodeData.docId)
  }, [hitTest, setSelectedNode, setSelectedDoc, openInEditor])

  return (
    <div style={{ position: 'relative', width, height }} data-testid="graph-2d">
      <canvas
        ref={canvasRef}
        width={width}
        height={height}
        style={{ display: 'block', cursor: 'grab' }}
        onMouseDown={handleMouseDown}
        onMouseMove={handleMouseMove}
        onMouseUp={handleMouseUp}
        onMouseLeave={handleMouseUp}
        onClick={handleClick}
        onDoubleClick={handleDoubleClick}
      />
      {tooltip && <NodeTooltip nodeId={tooltip.nodeId} x={tooltip.x} y={tooltip.y} />}
    </div>
  )
}
