import { useRef, useState, useCallback, useEffect, useLayoutEffect, useMemo, type CSSProperties } from 'react'
import { useGraphStore } from '@/stores/graphStore'
import { useUIStore } from '@/stores/uiStore'
import { useSettingsStore } from '@/stores/settingsStore'
import { useGraphSimulation, type SimNode, type SimLink } from '@/hooks/useGraphSimulation'
import { SPEAKER_CONFIG } from '@/lib/speakerConfig'
import { buildNodeColorMap, getNodeColor, lightenColor, degreeScaleFactor, DEGREE_SIZE_MIN, DEGREE_LIGHT_MAX } from '@/lib/nodeColors'
import type { GraphNode, GraphLink } from '@/types'
import NodeTooltip from './NodeTooltip'

interface Props {
  width: number
  height: number
}

const LABEL_Y_OFFSET = 16  // px below node center

export default function Graph2D({ width, height }: Props) {
  const { nodes, links, selectedNodeId, hoveredNodeId, aiHighlightNodeIds, setSelectedNode, setHoveredNode, physics, setGraphLayoutReady } = useGraphStore()
  const { setSelectedDoc, setCenterTab, centerTab, nodeColorMode, openInEditor } = useUIStore()
  const showNodeLabels = useSettingsStore(s => s.showNodeLabels)
  const isFast = useSettingsStore(s => s.paragraphRenderQuality === 'fast')
  const isFastRef = useRef(isFast)
  isFastRef.current = isFast
  const tagColors = useSettingsStore(s => s.tagColors)
  const folderColors = useSettingsStore(s => s.folderColors)

  const nodeColorMap = useMemo(
    () => buildNodeColorMap(nodes, nodeColorMode, tagColors, folderColors),
    [nodes, nodeColorMode, tagColors, folderColors]
  )

  // Degree map — Obsidian-style node sizing + brightness
  const { degreeMap, maxDegree } = useMemo(() => {
    const map = new Map<string, number>()
    for (const l of links) {
      const s = typeof l.source === 'string' ? l.source : (l.source as { id: string }).id
      const t = typeof l.target === 'string' ? l.target : (l.target as { id: string }).id
      map.set(s, (map.get(s) ?? 0) + 1)
      map.set(t, (map.get(t) ?? 0) + 1)
    }
    return { degreeMap: map, maxDegree: Math.max(1, ...map.values()) }
  }, [links])

  // DOM refs — updated imperatively in simulation tick (avoids React re-render per frame)
  // SVGCircleElement (doc nodes) or SVGRectElement (image nodes)
  const nodeEls = useRef<Map<string, SVGCircleElement | SVGRectElement>>(new Map())
  const labelEls = useRef<Map<string, SVGTextElement>>(new Map())
  const linkEls = useRef<Map<number, SVGLineElement>>(new Map())
  const selRingEl = useRef<SVGCircleElement | null>(null)

  // Ref-based selected ID — keeps handleTick stable (no deps on selectedNodeId)
  const selectedNodeIdRef = useRef(selectedNodeId)
  selectedNodeIdRef.current = selectedNodeId

  // Pan/zoom refs — using refs (not state) to avoid re-renders that would reset imperative cx/cy
  const svgRef = useRef<SVGSVGElement>(null)
  const graphGroupRef = useRef<SVGGElement>(null)
  const labelGroupRef = useRef<SVGGElement>(null)
  const viewRef = useRef({ x: 0, y: 0, scale: 1 })
  const isPanningRef = useRef(false)
  const panStartRef = useRef({ mx: 0, my: 0, tx: 0, ty: 0 })

  // Drag state — which node is being dragged
  const draggingNodeRef = useRef<string | null>(null)

  // Adjacency map: nodeId → Set<linkIndex> (built from graphStore links)
  const adjacencyRef = useRef<Map<string, Set<number>>>(new Map())
  // Node ID → node data map for O(1) lookups in hover effect
  const nodeDataMapRef = useRef<Map<string, GraphNode>>(new Map())
  // Track previously highlighted nodes/links for delta-only hover updates
  const prevHighlightedNodeIds = useRef<Set<string>>(new Set())
  const prevHighlightedLinkIdxs = useRef<Set<number>>(new Set())

  const [tooltip, setTooltip] = useState<{ nodeId: string; x: number; y: number } | null>(null)

  // ── Simulation tick — direct DOM mutation, no React state ──────────────────
  const handleTick = useCallback((simNodes: SimNode[], simLinks: SimLink[]) => {
    for (const node of simNodes) {
      const el = nodeEls.current.get(node.id)
      if (el) {
        if (el.tagName.toLowerCase() === 'rect') {
          // 이미지 노드(rect): x/y를 중심 기준으로 업데이트 + rotate transform
          const halfW = parseFloat(el.getAttribute('width') ?? '12') / 2
          el.setAttribute('x', String(node.x - halfW))
          el.setAttribute('y', String(node.y - halfW))
          el.setAttribute('transform', `rotate(45, ${node.x}, ${node.y})`)
        } else {
          el.setAttribute('cx', String(node.x))
          el.setAttribute('cy', String(node.y))
        }
      }
      const lEl = labelEls.current.get(node.id)
      if (lEl) {
        lEl.setAttribute('x', String(node.x ?? 0))
        lEl.setAttribute('y', String((node.y ?? 0) + LABEL_Y_OFFSET))
      }
    }
    const selId = selectedNodeIdRef.current
    if (selRingEl.current && selId) {
      const sel = simNodes.find(n => n.id === selId)
      if (sel) {
        selRingEl.current.setAttribute('cx', String(sel.x))
        selRingEl.current.setAttribute('cy', String(sel.y))
      }
    }
    simLinks.forEach((link, i) => {
      const el = linkEls.current.get(i)
      if (!el) return
      const src = link.source as SimNode
      const tgt = link.target as SimNode
      el.setAttribute('x1', String(src.x ?? 0))
      el.setAttribute('y1', String(src.y ?? 0))
      el.setAttribute('x2', String(tgt.x ?? 0))
      el.setAttribute('y2', String(tgt.y ?? 0))
    })
  }, [])  // stable — reads selectedNodeId via ref, no deps needed

  // ── Fit all nodes into viewport ───────────────────────────────────────────
  const fitView = useCallback((simNodes: SimNode[]) => {
    if (simNodes.length === 0 || !graphGroupRef.current) return
    let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity
    for (const n of simNodes) {
      if (n.x < minX) minX = n.x
      if (n.x > maxX) maxX = n.x
      if (n.y < minY) minY = n.y
      if (n.y > maxY) maxY = n.y
    }
    const graphW = Math.max(maxX - minX, 100)
    const graphH = Math.max(maxY - minY, 100)
    const padding = 48
    const scaleX = (width - padding * 2) / graphW
    const scaleY = (height - padding * 2) / graphH
    const scale = Math.min(scaleX, scaleY, 2)
    const cx = (minX + maxX) / 2
    const cy = (minY + maxY) / 2
    viewRef.current = { x: width / 2 - cx * scale, y: height / 2 - cy * scale, scale }
    graphGroupRef.current.setAttribute(
      'transform',
      `translate(${viewRef.current.x},${viewRef.current.y}) scale(${viewRef.current.scale})`
    )
    setGraphLayoutReady(true)
  }, [width, height, setGraphLayoutReady])

  const { simRef, simNodesRef } = useGraphSimulation({ width, height, onTick: handleTick, onComplete: fitView })

  // ── Node data map: ID → GraphNode for O(1) hover lookups ─────────────────
  useEffect(() => {
    nodeDataMapRef.current = new Map(nodes.map(n => [n.id, n]))
  }, [nodes])

  // ── Build adjacency map whenever links change ──────────────────────────────
  useEffect(() => {
    const map = new Map<string, Set<number>>()
    links.forEach((link: GraphLink, i: number) => {
      const src = typeof link.source === 'string' ? link.source : (link.source as GraphNode).id
      const tgt = typeof link.target === 'string' ? link.target : (link.target as GraphNode).id
      if (!map.has(src)) map.set(src, new Set())
      if (!map.has(tgt)) map.set(tgt, new Set())
      map.get(src)!.add(i)
      map.get(tgt)!.add(i)
    })
    adjacencyRef.current = map
  }, [links])

  // ── Helper: client coords → graph (simulation) coords ─────────────────────
  const clientToGraph = useCallback((clientX: number, clientY: number) => {
    const el = svgRef.current
    if (!el) return { x: 0, y: 0 }
    const rect = el.getBoundingClientRect()
    const v = viewRef.current
    return {
      x: (clientX - rect.left - v.x) / v.scale,
      y: (clientY - rect.top - v.y) / v.scale,
    }
  }, [])

  // ── Pan/zoom: wheel zoom ──────────────────────────────────────────────────
  const handleWheel = useCallback((e: WheelEvent) => {
    e.preventDefault()
    const view = viewRef.current
    const el = svgRef.current
    if (!el) return
    const rect = el.getBoundingClientRect()
    const mouseX = e.clientX - rect.left
    const mouseY = e.clientY - rect.top
    const zoomFactor = e.deltaY < 0 ? 1.12 : 1 / 1.12
    const newScale = Math.min(6, Math.max(0.15, view.scale * zoomFactor))
    const ratio = newScale / view.scale
    viewRef.current = {
      x: mouseX - ratio * (mouseX - view.x),
      y: mouseY - ratio * (mouseY - view.y),
      scale: newScale,
    }
    if (graphGroupRef.current) {
      const v = viewRef.current
      graphGroupRef.current.setAttribute('transform', `translate(${v.x},${v.y}) scale(${v.scale})`)
    }
  }, [])

  // Register non-passive wheel listener (React synthetic events are passive by default)
  useEffect(() => {
    const el = svgRef.current
    if (!el) return
    el.addEventListener('wheel', handleWheel, { passive: false })
    return () => el.removeEventListener('wheel', handleWheel)
  }, [handleWheel])

  // ── Global mouseup: release drag or pan even when mouse leaves SVG ─────────
  useEffect(() => {
    const handleGlobalUp = () => {
      if (draggingNodeRef.current) {
        const simNode = simNodesRef.current.find(n => n.id === draggingNodeRef.current)
        if (simNode) {
          simNode.fx = null
          simNode.fy = null
        }
        simRef.current?.alphaTarget(0)
        draggingNodeRef.current = null
        setHoveredNode(null)
        setTooltip(null)
      }
      if (isPanningRef.current) {
        isPanningRef.current = false
        if (svgRef.current) svgRef.current.style.cursor = 'grab'
      }
    }
    window.addEventListener('mouseup', handleGlobalUp)
    return () => window.removeEventListener('mouseup', handleGlobalUp)
  }, [simNodesRef, simRef, setHoveredNode])

  // ── Pan/zoom: mouse drag (background only) ────────────────────────────────
  const handleSVGMouseDown = useCallback((e: React.MouseEvent<SVGSVGElement>) => {
    // Only pan on background, not on interactive nodes/text
    const target = e.target as Element
    if (target.closest('circle') || target.closest('text')) return
    isPanningRef.current = true
    panStartRef.current = {
      mx: e.clientX,
      my: e.clientY,
      tx: viewRef.current.x,
      ty: viewRef.current.y,
    }
    if (svgRef.current) svgRef.current.style.cursor = 'grabbing'
  }, [])

  const handleSVGMouseMove = useCallback((e: React.MouseEvent<SVGSVGElement>) => {
    // Node drag takes priority over background pan
    if (draggingNodeRef.current) {
      setTooltip(null)  // clear tooltip as soon as drag begins
      const { x, y } = clientToGraph(e.clientX, e.clientY)
      const simNode = simNodesRef.current.find(n => n.id === draggingNodeRef.current)
      if (simNode) {
        simNode.fx = x
        simNode.fy = y
        simRef.current?.alphaTarget(0.3).restart()
      }
      return
    }
    if (!isPanningRef.current) return
    const dx = e.clientX - panStartRef.current.mx
    const dy = e.clientY - panStartRef.current.my
    viewRef.current = {
      ...viewRef.current,
      x: panStartRef.current.tx + dx,
      y: panStartRef.current.ty + dy,
    }
    if (graphGroupRef.current) {
      const v = viewRef.current
      graphGroupRef.current.setAttribute('transform', `translate(${v.x},${v.y}) scale(${v.scale})`)
    }
  }, [clientToGraph, simNodesRef, simRef])

  const handleSVGMouseUp = useCallback(() => {
    if (draggingNodeRef.current) {
      const simNode = simNodesRef.current.find(n => n.id === draggingNodeRef.current)
      if (simNode) {
        simNode.fx = null
        simNode.fy = null
      }
      simRef.current?.alphaTarget(0)
      draggingNodeRef.current = null
      if (svgRef.current) svgRef.current.style.cursor = 'grab'
      return
    }
    isPanningRef.current = false
    if (svgRef.current) svgRef.current.style.cursor = 'grab'
  }, [simNodesRef, simRef])

  // ── Hide label group only when overlay panel is active (opacity controls per-label) ──
  useEffect(() => {
    if (!labelGroupRef.current) return
    labelGroupRef.current.style.display = centerTab === 'graph' ? '' : 'none'
  }, [centerTab])

  // ── Inject styles once on mount ───────────────────────────────────────────
  useEffect(() => {
    const style = document.createElement('style')
    style.textContent = `
      @keyframes aiScan {
        0%, 100% { opacity: 0.45; }
        50%       { opacity: 1; }
      }
      .graph-faded circle:not([data-hl]) { opacity: 0.12 !important; filter: none !important; }
      .graph-faded line:not([data-hl])   { opacity: 0.04 !important; stroke: var(--color-border) !important; stroke-width: 1px !important; }
      .graph-faded text:not([data-hl])   { opacity: 0 !important; }
      .graph-ai-faded circle:not([data-hl]) { opacity: 0.1 !important; filter: none !important; }
      .graph-ai-faded line  { opacity: 0.05 !important; }
      .graph-ai-faded text:not([data-hl])   { opacity: 0 !important; }
    `
    document.head.appendChild(style)
    return () => { style.remove() }
  }, [])

  // ── AI highlight: pulse + fade non-highlighted nodes ─────────────────────
  useLayoutEffect(() => {
    const nodeMap = nodeEls.current
    const graphGroup = graphGroupRef.current
    if (aiHighlightNodeIds.length === 0) {
      graphGroup?.classList.remove('graph-ai-faded')
      nodeMap.forEach(el => {
        el.style.animation = ''
        el.removeAttribute('data-hl')
      })
      return
    }
    const highlightSet = new Set(aiHighlightNodeIds)
    graphGroup?.classList.add('graph-ai-faded')
    nodes.forEach(n => {
      const el = nodeMap.get(n.id)
      if (!el) return
      if (highlightSet.has(n.docId)) {
        el.setAttribute('data-hl', '1')
        el.style.animation = 'aiScan 1.4s ease-in-out infinite'
      } else {
        el.removeAttribute('data-hl')
        el.style.animation = ''
      }
    })
  }, [aiHighlightNodeIds, nodes])

  // ── Node event handlers ───────────────────────────────────────────────────

  // Start dragging: pin node at current mouse position, activate highlight + show tooltip
  const handleNodeMouseDown = useCallback((nodeId: string, e: React.MouseEvent) => {
    e.stopPropagation()  // prevent SVG pan from starting
    draggingNodeRef.current = nodeId
    const { x, y } = clientToGraph(e.clientX, e.clientY)
    const simNode = simNodesRef.current.find(n => n.id === nodeId)
    if (simNode) {
      simNode.fx = x
      simNode.fy = y
      simRef.current?.alphaTarget(0.3).restart()
    }
    if (svgRef.current) svgRef.current.style.cursor = 'grabbing'
    setHoveredNode(nodeId)
    setTooltip({ nodeId, x: e.clientX, y: e.clientY })
  }, [clientToGraph, simNodesRef, simRef, setHoveredNode])

  // Single click: just select the node (highlight in graph, no tab switch)
  const handleNodeClick = useCallback((nodeId: string) => {
    setSelectedNode(nodeId)
  }, [setSelectedNode])

  // Double click: select + open editor (skip phantom nodes)
  const handleNodeDoubleClick = useCallback((nodeId: string, docId: string) => {
    setSelectedNode(nodeId)
    setSelectedDoc(docId)
    if (!docId.startsWith('_phantom_')) openInEditor(docId)
  }, [setSelectedNode, setSelectedDoc, openInEditor])

  // Hover: highlight only — tooltip appears on mousedown/click, not hover
  // Fast mode: skip hover entirely (no label reveal, no neighbor highlight)
  const handleMouseEnter = useCallback((nodeId: string) => {
    if (isFastRef.current) return
    setHoveredNode(nodeId)
  }, [setHoveredNode])

  const handleMouseLeave = useCallback(() => {
    // Don't clear hover while actively dragging this node
    if (draggingNodeRef.current) return
    setHoveredNode(null)
    setTooltip(null)
  }, [setHoveredNode])

  // ── Neighbor highlight — O(k) delta updates via CSS class + data-hl attr ───
  useLayoutEffect(() => {
    const nodeMap = nodeEls.current
    const labelMap = labelEls.current
    const linkMap = linkEls.current
    const graphGroup = graphGroupRef.current

    if (!hoveredNodeId) {
      // O(1): remove faded class → CSS restores all opacities
      graphGroup?.classList.remove('graph-faded')
      // O(k): restore only previously highlighted elements
      prevHighlightedNodeIds.current.forEach(nodeId => {
        const el = nodeMap.get(nodeId)
        if (el) { el.removeAttribute('data-hl'); el.style.filter = '' }
        const lEl = labelMap.get(nodeId)
        if (lEl) { lEl.removeAttribute('data-hl'); lEl.style.opacity = '' }
      })
      prevHighlightedLinkIdxs.current.forEach(i => {
        const el = linkMap.get(i)
        if (el) { el.removeAttribute('data-hl'); el.style.stroke = ''; el.style.strokeWidth = '' }
      })
      prevHighlightedNodeIds.current = new Set()
      prevHighlightedLinkIdxs.current = new Set()
      return
    }

    // Resolve neighbor link indices and node IDs — O(k_links) only
    const neighborLinkIdxs = adjacencyRef.current.get(hoveredNodeId) ?? new Set<number>()
    const neighborIds = new Set<string>([hoveredNodeId])
    neighborLinkIdxs.forEach(i => {
      const link = links[i] as GraphLink | undefined
      if (!link) return
      neighborIds.add(typeof link.source === 'string' ? link.source : (link.source as GraphNode).id)
      neighborIds.add(typeof link.target === 'string' ? link.target : (link.target as GraphNode).id)
    })

    const hovNode = nodeDataMapRef.current.get(hoveredNodeId)
    const accentColor = hovNode ? SPEAKER_CONFIG[hovNode.speaker].color : '#ffffff'

    // O(1): fade everything via CSS class (no per-node loop needed)
    graphGroup?.classList.add('graph-faded')

    // O(prevK): clear data-hl from nodes/links no longer highlighted
    prevHighlightedNodeIds.current.forEach(nodeId => {
      if (!neighborIds.has(nodeId)) {
        const el = nodeMap.get(nodeId)
        if (el) { el.removeAttribute('data-hl'); el.style.filter = '' }
        const lEl = labelMap.get(nodeId)
        if (lEl) { lEl.removeAttribute('data-hl'); lEl.style.opacity = '' }
      }
    })
    prevHighlightedLinkIdxs.current.forEach(i => {
      if (!neighborLinkIdxs.has(i)) {
        const el = linkMap.get(i)
        if (el) { el.removeAttribute('data-hl'); el.style.stroke = ''; el.style.strokeWidth = '' }
      }
    })

    // O(k): set data-hl + glow on highlighted nodes
    neighborIds.forEach(nodeId => {
      const el = nodeMap.get(nodeId)
      if (!el) return
      el.setAttribute('data-hl', '1')
      const nd = nodeDataMapRef.current.get(nodeId)
      el.style.filter = nodeId === hoveredNodeId
        ? `drop-shadow(0 0 10px ${accentColor}) drop-shadow(0 0 4px ${accentColor})`
        : nd ? `drop-shadow(0 0 5px ${SPEAKER_CONFIG[nd.speaker].color}99)` : ''
      const lEl = labelMap.get(nodeId)
      if (lEl) { lEl.setAttribute('data-hl', '1'); lEl.style.opacity = '1' }
    })
    // O(k): set data-hl + accent on highlighted links
    neighborLinkIdxs.forEach(i => {
      const el = linkMap.get(i)
      if (el) { el.setAttribute('data-hl', '1'); el.style.stroke = accentColor; el.style.strokeWidth = '2' }
    })

    prevHighlightedNodeIds.current = neighborIds
    prevHighlightedLinkIdxs.current = neighborLinkIdxs
  }, [hoveredNodeId, links, showNodeLabels])

  return (
    <div style={{ position: 'relative', width, height }} data-testid="graph-2d">
      <svg
        ref={svgRef}
        width={width}
        height={height}
        style={{ display: 'block', cursor: 'grab' }}
        onMouseDown={handleSVGMouseDown}
        onMouseMove={handleSVGMouseMove}
        onMouseUp={handleSVGMouseUp}
        onMouseLeave={handleSVGMouseUp}
      >
        {/* Single transform group — pan/zoom applied here, sim tick updates positions inside */}
        <g ref={graphGroupRef}>
          {/* Links */}
          <g data-testid="graph-links">
            {links.map((link: GraphLink, i: number) => {
              const src = typeof link.source === 'string' ? link.source : (link.source as GraphNode).id
              const tgt = typeof link.target === 'string' ? link.target : (link.target as GraphNode).id
              return (
                <line
                  key={`${src}-${tgt}-${i}`}
                  ref={el => { if (el) linkEls.current.set(i, el) }}
                  x1={width / 2} y1={height / 2}
                  x2={width / 2} y2={height / 2}
                  stroke="var(--color-border)"
                  strokeWidth={1}
                  strokeOpacity={physics.linkOpacity}
                />
              )
            })}
          </g>

          {/* Selection ring */}
          {selectedNodeId && (() => {
            const node = nodes.find(n => n.id === selectedNodeId)
            if (!node) return null
            const color = SPEAKER_CONFIG[node.speaker].color
            return (
              <circle
                ref={el => { selRingEl.current = el }}
                cx={width / 2} cy={height / 2}
                r={15}
                fill="none"
                stroke={color}
                strokeWidth={1.5}
                strokeDasharray="4 3"
                opacity={0.8}
                data-testid="selection-ring"
              />
            )
          })()}

          {/* Nodes */}
          <g data-testid="graph-nodes">
            {nodes.map(node => {
              const baseColor = getNodeColor(node, nodeColorMode, nodeColorMap)
              const isSelected = selectedNodeId === node.id

              // Degree-based size + brightness (Obsidian style)
              const deg = degreeMap.get(node.id) ?? 0
              const sf = degreeScaleFactor(deg, maxDegree)
              const nr = physics.nodeRadius * (DEGREE_SIZE_MIN + sf * (1 - DEGREE_SIZE_MIN))
              const lightFactor = isSelected ? 0 : (1 - sf) * DEGREE_LIGHT_MAX
              const color = lightFactor > 0.01 ? lightenColor(baseColor, lightFactor) : baseColor

              const commonProps = {
                key: node.id,
                fill: color,
                fillOpacity: isSelected ? 1 : 0.9,
                style: {
                  cursor: 'grab',
                  filter: isSelected ? `drop-shadow(0 0 6px ${baseColor})` : undefined,
                  transition: isFast ? undefined : 'r 0.15s, fill-opacity 0.15s',
                } as CSSProperties,
                onClick: () => handleNodeClick(node.id),
                onDoubleClick: () => handleNodeDoubleClick(node.id, node.docId),
                onMouseDown: (e: React.MouseEvent) => handleNodeMouseDown(node.id, e),
                onMouseEnter: () => handleMouseEnter(node.id),
                onMouseLeave: handleMouseLeave,
                'data-node-id': node.id,
              }
              if (node.isImage) {
                // 이미지 노드: 다이아몬드(마름모) — rect를 45도 회전
                const s = isSelected ? nr + 1.5 : Math.max(nr - 1, 2)
                return (
                  <rect
                    ref={el => { if (el) nodeEls.current.set(node.id, el) }}
                    x={width / 2 - s} y={height / 2 - s}
                    width={s * 2} height={s * 2}
                    transform={`rotate(45, ${width / 2}, ${height / 2})`}
                    {...commonProps}
                  />
                )
              }
              return (
                <circle
                  ref={el => { if (el) nodeEls.current.set(node.id, el) }}
                  cx={width / 2} cy={height / 2}
                  r={isSelected ? nr + 3 : nr}
                  {...commonProps}
                />
              )
            })}
          </g>

          {/* Labels group — hidden when overlay panel active; positions always live-updated by tick */}
          <g ref={labelGroupRef} data-testid="graph-labels">
            {nodes.map(node => (
              <text
                key={`label-${node.id}`}
                ref={el => { if (el) labelEls.current.set(node.id, el) }}
                x={width / 2}
                y={height / 2 + LABEL_Y_OFFSET}
                textAnchor="middle"
                fontSize={11}
                fontWeight="normal"
                fill="var(--color-text-secondary)"
                stroke="var(--color-bg-primary)"
                strokeWidth={3}
                strokeLinejoin="round"
                paintOrder="stroke"
                opacity={showNodeLabels ? 0.95 : 0}
                pointerEvents="none"
                style={{ userSelect: 'none' }}
                data-testid={`node-label-${node.id}`}
              >
                {node.label.length > 16 ? node.label.slice(0, 15) + '…' : node.label}
              </text>
            ))}
          </g>
        </g>
      </svg>

      {tooltip && <NodeTooltip nodeId={tooltip.nodeId} x={tooltip.x} y={tooltip.y} />}
    </div>
  )
}
